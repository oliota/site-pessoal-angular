{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { InjectionToken, forwardRef, Directive, Optional, Inject, Input, HostListener, NgModule } from '@angular/core';\nimport { NG_VALUE_ACCESSOR, NG_VALIDATORS, FormsModule } from '@angular/forms';\nimport { CommonModule } from '@angular/common';\nlet CURRENCY_MASK_CONFIG = new InjectionToken(\"currency.mask.config\");\n\nclass InputManager {\n  constructor(htmlInputElement) {\n    this.htmlInputElement = htmlInputElement;\n  }\n\n  setCursorAt(position) {\n    if (this.htmlInputElement.setSelectionRange) {\n      this.htmlInputElement.focus();\n      this.htmlInputElement.setSelectionRange(position, position);\n    } else if (this.htmlInputElement.createTextRange) {\n      let textRange = this.htmlInputElement.createTextRange();\n      textRange.collapse(true);\n      textRange.moveEnd(\"character\", position);\n      textRange.moveStart(\"character\", position);\n      textRange.select();\n    }\n  }\n\n  updateValueAndCursor(newRawValue, oldLength, selectionStart) {\n    this.rawValue = newRawValue;\n    let newLength = newRawValue.length;\n    selectionStart = selectionStart - (oldLength - newLength);\n    this.setCursorAt(selectionStart);\n  }\n\n  get canInputMoreNumbers() {\n    let haventReachedMaxLength = !(this.rawValue.length >= this.htmlInputElement.maxLength && this.htmlInputElement.maxLength >= 0);\n    let selectionStart = this.inputSelection.selectionStart;\n    let selectionEnd = this.inputSelection.selectionEnd;\n    let haveNumberSelected = selectionStart != selectionEnd && this.htmlInputElement.value.substring(selectionStart, selectionEnd).match(/\\d/) ? true : false;\n    let startWithZero = this.htmlInputElement.value.substring(0, 1) == \"0\";\n    return haventReachedMaxLength || haveNumberSelected || startWithZero;\n  }\n\n  get inputSelection() {\n    let selectionStart = 0;\n    let selectionEnd = 0;\n\n    if (typeof this.htmlInputElement.selectionStart == \"number\" && typeof this.htmlInputElement.selectionEnd == \"number\") {\n      selectionStart = this.htmlInputElement.selectionStart;\n      selectionEnd = this.htmlInputElement.selectionEnd;\n    } else {\n      let range = document.getSelection().anchorNode;\n\n      if (range && range.firstChild == this.htmlInputElement) {\n        let lenght = this.htmlInputElement.value.length;\n        let normalizedValue = this.htmlInputElement.value.replace(/\\r\\n/g, \"\\n\");\n        let startRange = this.htmlInputElement.createTextRange();\n        let endRange = this.htmlInputElement.createTextRange();\n        endRange.collapse(false);\n\n        if (startRange.compareEndPoints(\"StartToEnd\", endRange) > -1) {\n          selectionStart = selectionEnd = lenght;\n        } else {\n          selectionStart = -startRange.moveStart(\"character\", -lenght);\n          selectionStart += normalizedValue.slice(0, selectionStart).split(\"\\n\").length - 1;\n\n          if (startRange.compareEndPoints(\"EndToEnd\", endRange) > -1) {\n            selectionEnd = lenght;\n          } else {\n            selectionEnd = -startRange.moveEnd(\"character\", -lenght);\n            selectionEnd += normalizedValue.slice(0, selectionEnd).split(\"\\n\").length - 1;\n          }\n        }\n      }\n    }\n\n    return {\n      selectionStart: selectionStart,\n      selectionEnd: selectionEnd\n    };\n  }\n\n  get rawValue() {\n    return this.htmlInputElement && this.htmlInputElement.value;\n  }\n\n  set rawValue(value) {\n    this._storedRawValue = value;\n\n    if (this.htmlInputElement) {\n      this.htmlInputElement.value = value;\n    }\n  }\n\n  get storedRawValue() {\n    return this._storedRawValue;\n  }\n\n}\n\nclass InputService {\n  constructor(htmlInputElement, options) {\n    this.htmlInputElement = htmlInputElement;\n    this.options = options;\n    this.inputManager = new InputManager(htmlInputElement);\n  }\n\n  addNumber(keyCode) {\n    if (!this.rawValue) {\n      this.rawValue = this.applyMask(false, \"0\");\n    }\n\n    let keyChar = String.fromCharCode(keyCode);\n    let selectionStart = this.inputSelection.selectionStart;\n    let selectionEnd = this.inputSelection.selectionEnd;\n    this.rawValue = this.rawValue.substring(0, selectionStart) + keyChar + this.rawValue.substring(selectionEnd, this.rawValue.length);\n    this.updateFieldValue(selectionStart + 1);\n  }\n\n  applyMask(isNumber, rawValue) {\n    let {\n      allowNegative,\n      decimal,\n      precision,\n      prefix,\n      suffix,\n      thousands\n    } = this.options;\n    rawValue = isNumber ? new Number(rawValue).toFixed(precision) : rawValue;\n    let onlyNumbers = rawValue.replace(/[^0-9]/g, \"\");\n\n    if (!onlyNumbers) {\n      return \"\";\n    }\n\n    let integerPart = onlyNumbers.slice(0, onlyNumbers.length - precision).replace(/^0*/g, \"\").replace(/\\B(?=(\\d{3})+(?!\\d))/g, thousands);\n\n    if (integerPart == \"\") {\n      integerPart = \"0\";\n    }\n\n    let newRawValue = integerPart;\n    let decimalPart = onlyNumbers.slice(onlyNumbers.length - precision);\n\n    if (precision > 0) {\n      decimalPart = \"0\".repeat(precision - decimalPart.length) + decimalPart;\n      newRawValue += decimal + decimalPart;\n    }\n\n    let isZero = parseInt(integerPart) == 0 && (parseInt(decimalPart) == 0 || decimalPart == \"\");\n    let operator = rawValue.indexOf(\"-\") > -1 && allowNegative && !isZero ? \"-\" : \"\";\n    return operator + prefix + newRawValue + suffix;\n  }\n\n  clearMask(rawValue) {\n    if (rawValue == null || rawValue == \"\") {\n      return null;\n    }\n\n    let value = rawValue.replace(this.options.prefix, \"\").replace(this.options.suffix, \"\");\n\n    if (this.options.thousands) {\n      value = value.replace(new RegExp(\"\\\\\" + this.options.thousands, \"g\"), \"\");\n    }\n\n    if (this.options.decimal) {\n      value = value.replace(this.options.decimal, \".\");\n    }\n\n    return parseFloat(value);\n  }\n\n  changeToNegative() {\n    if (this.options.allowNegative && this.rawValue != \"\" && this.rawValue.charAt(0) != \"-\" && this.value != 0) {\n      let selectionStart = this.inputSelection.selectionStart;\n      this.rawValue = \"-\" + this.rawValue;\n      this.updateFieldValue(selectionStart + 1);\n    }\n  }\n\n  changeToPositive() {\n    let selectionStart = this.inputSelection.selectionStart;\n    this.rawValue = this.rawValue.replace(\"-\", \"\");\n    this.updateFieldValue(selectionStart - 1);\n  }\n\n  fixCursorPosition(forceToEndPosition) {\n    let currentCursorPosition = this.inputSelection.selectionStart; //if the current cursor position is after the number end position, it is moved to the end of the number, ignoring the prefix or suffix. this behavior can be forced with forceToEndPosition flag\n\n    if (currentCursorPosition > this.getRawValueWithoutSuffixEndPosition() || forceToEndPosition) {\n      this.inputManager.setCursorAt(this.getRawValueWithoutSuffixEndPosition()); //if the current cursor position is before the number start position, it is moved to the start of the number, ignoring the prefix or suffix\n    } else if (currentCursorPosition < this.getRawValueWithoutPrefixStartPosition()) {\n      this.inputManager.setCursorAt(this.getRawValueWithoutPrefixStartPosition());\n    }\n  }\n\n  getRawValueWithoutSuffixEndPosition() {\n    return this.rawValue.length - this.options.suffix.length;\n  }\n\n  getRawValueWithoutPrefixStartPosition() {\n    return this.value != null && this.value < 0 ? this.options.prefix.length + 1 : this.options.prefix.length;\n  }\n\n  removeNumber(keyCode) {\n    let {\n      decimal,\n      thousands\n    } = this.options;\n    let selectionEnd = this.inputSelection.selectionEnd;\n    let selectionStart = this.inputSelection.selectionStart;\n\n    if (selectionStart > this.rawValue.length - this.options.suffix.length) {\n      selectionEnd = this.rawValue.length - this.options.suffix.length;\n      selectionStart = this.rawValue.length - this.options.suffix.length;\n    } //there is no selection\n\n\n    if (selectionEnd == selectionStart) {\n      //delete key and the target digit is a number\n      if ((keyCode == 46 || keyCode == 63272) && /^\\d+$/.test(this.rawValue.substring(selectionStart, selectionEnd + 1))) {\n        selectionEnd = selectionEnd + 1;\n      } //delete key and the target digit is the decimal or thousands divider\n\n\n      if ((keyCode == 46 || keyCode == 63272) && (this.rawValue.substring(selectionStart, selectionEnd + 1) == decimal || this.rawValue.substring(selectionStart, selectionEnd + 1) == thousands)) {\n        selectionEnd = selectionEnd + 2;\n        selectionStart = selectionStart + 1;\n      } //backspace key and the target digit is a number\n\n\n      if (keyCode == 8 && /^\\d+$/.test(this.rawValue.substring(selectionStart - 1, selectionEnd))) {\n        selectionStart = selectionStart - 1;\n      } //backspace key and the target digit is the decimal or thousands divider\n\n\n      if (keyCode == 8 && (this.rawValue.substring(selectionStart - 1, selectionEnd) == decimal || this.rawValue.substring(selectionStart - 1, selectionEnd) == thousands)) {\n        selectionStart = selectionStart - 2;\n        selectionEnd = selectionEnd - 1;\n      }\n    }\n\n    this.rawValue = this.rawValue.substring(0, selectionStart) + this.rawValue.substring(selectionEnd, this.rawValue.length);\n    this.updateFieldValue(selectionStart);\n  }\n\n  updateFieldValue(selectionStart) {\n    let newRawValue = this.applyMask(false, this.rawValue || \"\");\n    selectionStart = selectionStart == undefined ? this.rawValue.length : selectionStart;\n    this.inputManager.updateValueAndCursor(newRawValue, this.rawValue.length, selectionStart);\n  }\n\n  updateOptions(options) {\n    let value = this.value;\n    this.options = options;\n    this.value = value;\n  }\n\n  get canInputMoreNumbers() {\n    return this.inputManager.canInputMoreNumbers;\n  }\n\n  get inputSelection() {\n    return this.inputManager.inputSelection;\n  }\n\n  get rawValue() {\n    return this.inputManager.rawValue;\n  }\n\n  set rawValue(value) {\n    this.inputManager.rawValue = value;\n  }\n\n  get storedRawValue() {\n    return this.inputManager.storedRawValue;\n  }\n\n  get value() {\n    return this.clearMask(this.rawValue);\n  }\n\n  set value(value) {\n    this.rawValue = this.applyMask(true, \"\" + value);\n  }\n\n}\n\nclass InputHandler {\n  constructor(htmlInputElement, options) {\n    this.inputService = new InputService(htmlInputElement, options);\n    this.htmlInputElement = htmlInputElement;\n  }\n\n  handleClick(event, chromeAndroid) {\n    let selectionRangeLength = Math.abs(this.inputService.inputSelection.selectionEnd - this.inputService.inputSelection.selectionStart); //if there is no selection and the value is not null, the cursor position will be fixed. if the browser is chrome on android, the cursor will go to the end of the number.\n\n    if (selectionRangeLength == 0 && !isNaN(this.inputService.value)) {\n      this.inputService.fixCursorPosition(chromeAndroid);\n    }\n  }\n\n  handleCut(event) {\n    if (this.isReadOnly()) {\n      return;\n    }\n\n    setTimeout(() => {\n      this.inputService.updateFieldValue();\n      this.setValue(this.inputService.value);\n      this.onModelChange(this.inputService.value);\n    }, 0);\n  }\n\n  handleInput(event) {\n    if (this.isReadOnly()) {\n      return;\n    }\n\n    let keyCode = this.getNewKeyCode(this.inputService.storedRawValue, this.inputService.rawValue);\n    let rawValueLength = this.inputService.rawValue.length;\n    let rawValueSelectionEnd = this.inputService.inputSelection.selectionEnd;\n    let rawValueWithoutSuffixEndPosition = this.inputService.getRawValueWithoutSuffixEndPosition();\n    let storedRawValueLength = this.inputService.storedRawValue.length;\n    this.inputService.rawValue = this.inputService.storedRawValue;\n\n    if ((rawValueSelectionEnd != rawValueWithoutSuffixEndPosition || Math.abs(rawValueLength - storedRawValueLength) != 1) && storedRawValueLength != 0) {\n      this.setCursorPosition(event);\n      return;\n    }\n\n    if (rawValueLength < storedRawValueLength) {\n      if (this.inputService.value != 0) {\n        this.inputService.removeNumber(8);\n      } else {\n        this.setValue(null);\n      }\n    }\n\n    if (rawValueLength > storedRawValueLength) {\n      switch (keyCode) {\n        case 43:\n          this.inputService.changeToPositive();\n          break;\n\n        case 45:\n          this.inputService.changeToNegative();\n          break;\n\n        default:\n          if (!this.inputService.canInputMoreNumbers || isNaN(this.inputService.value) && String.fromCharCode(keyCode).match(/\\d/) == null) {\n            return;\n          }\n\n          this.inputService.addNumber(keyCode);\n      }\n    }\n\n    this.setCursorPosition(event);\n    this.onModelChange(this.inputService.value);\n  }\n\n  handleKeydown(event) {\n    if (this.isReadOnly()) {\n      return;\n    }\n\n    let keyCode = event.which || event.charCode || event.keyCode;\n\n    if (keyCode == 8 || keyCode == 46 || keyCode == 63272) {\n      event.preventDefault();\n      let selectionRangeLength = Math.abs(this.inputService.inputSelection.selectionEnd - this.inputService.inputSelection.selectionStart);\n\n      if (selectionRangeLength == this.inputService.rawValue.length || this.inputService.value == 0) {\n        this.setValue(null);\n        this.onModelChange(this.inputService.value);\n      }\n\n      if (selectionRangeLength == 0 && !isNaN(this.inputService.value)) {\n        this.inputService.removeNumber(keyCode);\n        this.onModelChange(this.inputService.value);\n      }\n\n      if ((keyCode === 8 || keyCode === 46) && selectionRangeLength != 0 && !isNaN(this.inputService.value)) {\n        this.inputService.removeNumber(keyCode);\n        this.onModelChange(this.inputService.value);\n      }\n    }\n  }\n\n  handleKeypress(event) {\n    if (this.isReadOnly()) {\n      return;\n    }\n\n    let keyCode = event.which || event.charCode || event.keyCode;\n\n    if (keyCode == undefined || [9, 13].indexOf(keyCode) != -1 || this.isArrowEndHomeKeyInFirefox(event)) {\n      return;\n    }\n\n    switch (keyCode) {\n      case 43:\n        this.inputService.changeToPositive();\n        break;\n\n      case 45:\n        this.inputService.changeToNegative();\n        break;\n\n      default:\n        if (this.inputService.canInputMoreNumbers && (!isNaN(this.inputService.value) || String.fromCharCode(keyCode).match(/\\d/) != null)) {\n          this.inputService.addNumber(keyCode);\n        }\n\n    }\n\n    event.preventDefault();\n    this.onModelChange(this.inputService.value);\n  }\n\n  handleKeyup(event) {\n    this.inputService.fixCursorPosition();\n  }\n\n  handlePaste(event) {\n    if (this.isReadOnly()) {\n      return;\n    }\n\n    setTimeout(() => {\n      this.inputService.updateFieldValue();\n      this.setValue(this.inputService.value);\n      this.onModelChange(this.inputService.value);\n    }, 1);\n  }\n\n  updateOptions(options) {\n    this.inputService.updateOptions(options);\n  }\n\n  getOnModelChange() {\n    return this.onModelChange;\n  }\n\n  setOnModelChange(callbackFunction) {\n    this.onModelChange = callbackFunction;\n  }\n\n  getOnModelTouched() {\n    return this.onModelTouched;\n  }\n\n  setOnModelTouched(callbackFunction) {\n    this.onModelTouched = callbackFunction;\n  }\n\n  setValue(value) {\n    this.inputService.value = value;\n  }\n\n  getNewKeyCode(oldString, newString) {\n    if (oldString.length > newString.length) {\n      return null;\n    }\n\n    for (let x = 0; x < newString.length; x++) {\n      if (oldString.length == x || oldString[x] != newString[x]) {\n        return newString.charCodeAt(x);\n      }\n    }\n\n    return null;\n  }\n\n  isArrowEndHomeKeyInFirefox(event) {\n    if ([35, 36, 37, 38, 39, 40].indexOf(event.keyCode) != -1 && (event.charCode == undefined || event.charCode == 0)) {\n      return true;\n    }\n\n    return false;\n  }\n\n  isReadOnly() {\n    return this.htmlInputElement && this.htmlInputElement.readOnly;\n  }\n\n  setCursorPosition(event) {\n    let rawValueWithoutSuffixEndPosition = this.inputService.getRawValueWithoutSuffixEndPosition(); // For some reason, in Android, the event got override before the timeout and change the target.\n\n    const inputElement = event.target;\n    setTimeout(function () {\n      inputElement.setSelectionRange(rawValueWithoutSuffixEndPosition, rawValueWithoutSuffixEndPosition);\n    }, 0);\n  }\n\n}\n\nconst CURRENCYMASKDIRECTIVE_VALUE_ACCESSOR = {\n  provide: NG_VALUE_ACCESSOR,\n  useExisting: forwardRef(() => CurrencyMaskDirective),\n  multi: true\n};\nlet CurrencyMaskDirective = /*#__PURE__*/(() => {\n  class CurrencyMaskDirective {\n    constructor(currencyMaskConfig, elementRef, keyValueDiffers) {\n      this.currencyMaskConfig = currencyMaskConfig;\n      this.elementRef = elementRef;\n      this.keyValueDiffers = keyValueDiffers;\n      this.options = {};\n      this.optionsTemplate = {\n        align: \"right\",\n        allowNegative: true,\n        decimal: \".\",\n        precision: 2,\n        prefix: \"$ \",\n        suffix: \"\",\n        thousands: \",\"\n      };\n\n      if (currencyMaskConfig) {\n        this.optionsTemplate = currencyMaskConfig;\n      }\n\n      this.keyValueDiffer = keyValueDiffers.find({}).create();\n    }\n\n    ngAfterViewInit() {\n      this.elementRef.nativeElement.style.textAlign = this.options.align ? this.options.align : this.optionsTemplate.align;\n    }\n\n    ngDoCheck() {\n      if (this.keyValueDiffer.diff(this.options)) {\n        this.elementRef.nativeElement.style.textAlign = this.options.align ? this.options.align : this.optionsTemplate.align;\n        this.inputHandler.updateOptions(Object.assign({}, this.optionsTemplate, this.options));\n      }\n    }\n\n    ngOnInit() {\n      this.inputHandler = new InputHandler(this.elementRef.nativeElement, Object.assign({}, this.optionsTemplate, this.options));\n    }\n\n    handleBlur(event) {\n      this.inputHandler.getOnModelTouched().apply(event);\n    }\n\n    handleClick(event) {\n      this.inputHandler.handleClick(event, this.isChromeAndroid());\n    }\n\n    handleCut(event) {\n      if (!this.isChromeAndroid()) {\n        this.inputHandler.handleCut(event);\n      }\n    }\n\n    handleInput(event) {\n      if (this.isChromeAndroid()) {\n        this.inputHandler.handleInput(event);\n      }\n    }\n\n    handleKeydown(event) {\n      if (!this.isChromeAndroid()) {\n        this.inputHandler.handleKeydown(event);\n      }\n    }\n\n    handleKeypress(event) {\n      if (!this.isChromeAndroid()) {\n        this.inputHandler.handleKeypress(event);\n      }\n    }\n\n    handleKeyup(event) {\n      if (!this.isChromeAndroid()) {\n        this.inputHandler.handleKeyup(event);\n      }\n    }\n\n    handlePaste(event) {\n      if (!this.isChromeAndroid()) {\n        this.inputHandler.handlePaste(event);\n      }\n    }\n\n    isChromeAndroid() {\n      return /chrome/i.test(navigator.userAgent) && /android/i.test(navigator.userAgent);\n    }\n\n    registerOnChange(callbackFunction) {\n      this.inputHandler.setOnModelChange(callbackFunction);\n    }\n\n    registerOnTouched(callbackFunction) {\n      this.inputHandler.setOnModelTouched(callbackFunction);\n    }\n\n    setDisabledState(value) {\n      this.elementRef.nativeElement.disabled = value;\n    }\n\n    validate(abstractControl) {\n      let result = {};\n\n      if (abstractControl.value > this.max) {\n        result.max = true;\n      }\n\n      if (abstractControl.value < this.min) {\n        result.min = true;\n      }\n\n      return result != {} ? result : null;\n    }\n\n    writeValue(value) {\n      this.inputHandler.setValue(value);\n    }\n\n  }\n\n  CurrencyMaskDirective.ɵfac = function CurrencyMaskDirective_Factory(t) {\n    return new (t || CurrencyMaskDirective)(i0.ɵɵdirectiveInject(CURRENCY_MASK_CONFIG, 8), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.KeyValueDiffers));\n  };\n\n  CurrencyMaskDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: CurrencyMaskDirective,\n    selectors: [[\"\", \"currencyMask\", \"\"]],\n    hostBindings: function CurrencyMaskDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"blur\", function CurrencyMaskDirective_blur_HostBindingHandler($event) {\n          return ctx.handleBlur($event);\n        })(\"click\", function CurrencyMaskDirective_click_HostBindingHandler($event) {\n          return ctx.handleClick($event);\n        })(\"cut\", function CurrencyMaskDirective_cut_HostBindingHandler($event) {\n          return ctx.handleCut($event);\n        })(\"input\", function CurrencyMaskDirective_input_HostBindingHandler($event) {\n          return ctx.handleInput($event);\n        })(\"keydown\", function CurrencyMaskDirective_keydown_HostBindingHandler($event) {\n          return ctx.handleKeydown($event);\n        })(\"keypress\", function CurrencyMaskDirective_keypress_HostBindingHandler($event) {\n          return ctx.handleKeypress($event);\n        })(\"keyup\", function CurrencyMaskDirective_keyup_HostBindingHandler($event) {\n          return ctx.handleKeyup($event);\n        })(\"paste\", function CurrencyMaskDirective_paste_HostBindingHandler($event) {\n          return ctx.handlePaste($event);\n        });\n      }\n    },\n    inputs: {\n      max: \"max\",\n      min: \"min\",\n      options: \"options\"\n    },\n    features: [i0.ɵɵProvidersFeature([CURRENCYMASKDIRECTIVE_VALUE_ACCESSOR, {\n      provide: NG_VALIDATORS,\n      useExisting: CurrencyMaskDirective,\n      multi: true\n    }])]\n  });\n  return CurrencyMaskDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet CurrencyMaskModule = /*#__PURE__*/(() => {\n  class CurrencyMaskModule {}\n\n  CurrencyMaskModule.ɵfac = function CurrencyMaskModule_Factory(t) {\n    return new (t || CurrencyMaskModule)();\n  };\n\n  CurrencyMaskModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: CurrencyMaskModule\n  });\n  CurrencyMaskModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[CommonModule, FormsModule]]\n  });\n  return CurrencyMaskModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/*\n * Public API Surface of ng2-currency-mask\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { CURRENCYMASKDIRECTIVE_VALUE_ACCESSOR, CURRENCY_MASK_CONFIG, CurrencyMaskDirective, CurrencyMaskModule }; //# sourceMappingURL=ng2-currency-mask.mjs.map","map":null,"metadata":{},"sourceType":"module"}